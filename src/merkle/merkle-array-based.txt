Exploration of feasibility of using arrays to store merkle trees, using the
customary index arithmetic to navigate from parent to children and vice versa.

This means we must have space for a sufficiently large perfect binary tree, but
will wast some of it unless the number of leaves is a power of 2.

It has the attraction of just being a linear array of [32]byte hash values.

Blank Areas
-----------
There is no sentinel value for a hash.
So we must avoid consuming the holes rather than being able to detect a hole.
This means navigating only bottom up.

Sizing relationships
---------------------

Terms
    nLeaves
        eg 16 (rounded up to power of 2) - the driver of the shape
    height
        eg 4 - number of rows of nodes incl root
    totalNodes (storage)
        eg 32 - count of all nodes including leaves

Equations

   nLeaves = 2 ** height
   height = ceil(log[2](nLeaves))
   totalNodes = (2 ** (height + 1)) - 1


Index arithmetic
----------------

left child of P = (P * 2) +1
right child of P = (P * 2) +2
parent of child Q = (Q - 1) / 2 // with integer truncation

The nodes comprising a single row are contiguous.
We denote rows with numbers, with the root row being 0.
Then the nodes of a row in row N start at index (2 ** N) - 1

Use Cases Feasible?
--------------------


Building Use Case
-----------------
Real leaves = something we know
nLeaves = above rounded up to power of 2
height = ceil(log[2](nLeaves)
totalNodes = (2 ** (height + 1)) -1

allocate nodes storage

leafRowIdx = height -1
post hashes of all real leaves starting at (2 ** leafRowIdx) -1

init 
    nodeCountPrevRow = real leaf count

for remaining row indices working up to root {
    calc limit of row below we can read from = f(nodeCountPrevRow)
    calc how many nodes will add to this row, and indices of where will go
    visit this set of indices {
        calc indices of children
        get left child hash
        get right child hash (or duplicate left)
        calc new hash
        post it
    }
    Update nodeCountPrevRow = how many nodes added to this row
}

Eval Path Use case
------------------
find index of target record - and knowing is bottom row, find node with index
calc

now use idx arithmetic to find parent node etc

Note rationale in comments
    o  One mem alloc
    o  Less code
Note limitations in comments
    o  Some wasted space
    o  While can traverse up, cannot down


